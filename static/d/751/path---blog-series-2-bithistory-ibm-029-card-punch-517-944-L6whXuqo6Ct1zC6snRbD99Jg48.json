{"data":{"markdownRemark":{"htmlAst":{"type":"root","children":[{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Lines of code longer than 80 characters drive me crazy. I appreciate that this\nis pedantic. I've seen people on the internet make good arguments for why the\n80-character limit ought to be respected even on our modern Retina-display\nscreens, but those arguments hardly justify the visceral hatred I feel for even\nthat one protruding 81st character."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"There was once a golden era in which it was basically impossible to go over the\n80-character limit. The 80-character limit was a physical reality, because\nthere was no 81st column for an 81st character to fit in. Any programmers\nattempting to name a function something horrendously long and awful would\ndiscover, in a moment of delicious, slow-dawning horror, that there literally\nisn't room for their whole declaration."}]},{"type":"text","value":"\n"},{"type":"comment","value":"more"},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"This golden era was the era of punch card programming. By the 1960s, IBM's\npunch cards had set the standard and the standard was that punch cards had 80\ncolumns. The 80-column standard survived into the teletype and dumb terminal\nera and from there embedded itself into the nooks and crannies of our operating\nsystems. Today, when you launch your terminal emulator and open a new window,\nodds are it will be 80 characters wide, even though we now have plenty of\nscreen real estate and tend to favor longer identifiers over inscrutable\nnonsense like "},{"type":"element","tagName":"code","properties":{"className":["language-text"]},"children":[{"type":"text","value":"iswcntrl()"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"If questions on Quora are any indication, many people have trouble imagining\nwhat it must have been like to program computers using punch cards. I will\nadmit that for a long time I also didn't understand how punch card programming\ncould have worked, because it struck me as awfully labor-intensive to punch all\nthose holes. This was a misunderstanding; programmers never punched holes in\ncards the same way a train conductor does. They had card punch machines (also\nknown as key punches), which allowed them to punch holes in cards using a\ntypewriter-style keyboard. And card punches were hardly new technology—they\nwere around as early as the 1890s."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"One of the most widely used card punch machines was the IBM 029. It is perhaps\nthe best remembered card punch today."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/2bithistory/ibm029_front.jpg"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The IBM 029 was released in 1964 as part of IBM's System/360 rollout.\nSystem/360 was a family of computing systems and peripherals that would go on\nto dominate the mainframe computing market in the late 1960s. Like many of the\nother System/360 machines, the 029 was big. This was an era when the\ndistinction between computing machinery and furniture was blurry—the 029 was\nnot something you put on a table but an entire table in itself. The 029\nimproved upon its predecessor, the 026, by supporting new characters like\nparentheses and by generally being quieter. It had cool electric blue\nhighlights and was flat and angular whereas the 026 had a 1940s rounded,\nindustrial look. Another of its big selling points was that it could\nautomatically left-pad numeric fields with zeros, demonstrating that JavaScript\nprogrammers were not the first programmers too lazy to do their own\nleft-padding."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"But wait, you might say—IBM released a brand-new card punch in 1964? What about\nthat photograph of the Unix gods at Bell Labs using teletype machines in, like,\n1970? Weren't card punching machines passé by the mid- to late-1960s? Well, it\nmight surprise you to know that the 029 was available in IBM's catalog until as\nlate as 1984."},{"type":"element","tagName":"sup","properties":{"id":"fnref-1"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-1","className":["footnote-ref"]},"children":[{"type":"text","value":"1"}]}]},{"type":"text","value":" In fact, most programmers programmed using punch cards until\nwell into the 1970s. This doesn't make much sense given that there were people\nusing teletype machines during World War II. Indeed, the teletype is almost of\nthe same vintage as the card punch. The limiting factor, it turns out, was not\nthe availability of teletypes but the availability of computing time. What kept\npeople from using teletypes was that teletypes assumed an interactive, \"online\"\nmodel of communication with the computer. Before Unix and the invention of\ntimesharing operating systems, your interactive session with a computer would\nhave stopped everyone else from using it, a delay potentially costing thousands\nof dollars. So programmers instead wrote their programs offline using card\npunch machines and then fed them into mainframe computers later as batch jobs.\nPunch cards had the added benefit of being a cheap data store in an era where\ncheap, reliable data storage was hard to come by. Your programs lived in stacks\nof cards on your shelves rather than in files on your hard drive."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So what was it actually like using an IBM 029 card punch? That's hard to\nexplain without first taking a look at the cards themselves. A typical punch\ncard had 12 rows and 80 columns. The bottom nine rows were the digit rows,\nnumbered one through nine. These rows had the appropriate digit printed in each\ncolumn. The top three rows, called the \"zone\" rows, consisted of two blank rows\nand usually a zero row. Row 12 was at the very top of the card, followed by row\n11, then rows zero through nine. This somewhat confusing ordering meant that\nthe top edge of the card was called the 12 edge while the bottom was called the\nnine edge. A corner of each card was usually clipped to make it easier to keep\na stack of cards all turned around the right way."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"/2bithistory/card.png"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"When they were first invented, punch cards were meant to be punched with\ncircular holes, but IBM eventually realized that they could fit more columns on\na card if the holes were narrow rectangles. Different combinations of holes in\na column represented different characters. For human convenience, card punches\nlike the 029 would print each column's character at the top of the card at the\nsame time as punching the necessary holes. Digits were represented by one\npunched hole in the appropriate digit row. Alphabetical and symbolic characters\nwere represented by a hole in a zone row and then a combination of one or two\nholes in the digit rows. The letter A, for example, was represented by a hole\nin the 12 zone row and another hole in the one row. This was an encoding of\nsorts, sometimes called the Hollerith code, after the original inventor of the\npunch card machine. The encoding allowed for only a relatively small character\nset; lowercase letters, for example, were not represented. Some clever engineer\ntoday might wonder why punch cards didn't just use a binary encoding—after all,\nwith 12 rows, you could encode over 4000 characters. The Hollerith code was\nused instead because it ensured that no more than three holes ever appeared in\na single column. This preserved the structural integrity of the card. A binary\nencoding would have entailed so many holes that the card would have fallen\napart."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Cards came in different flavors. By the 1960s, 80 columns was the standard, but\nthose 80 columns could be used to represent different things. The basic punch\ncard was unlabeled, but cards meant for COBOL programming, for example, divided\nthe 80 columns into fields. On a COBOL card, the last eight columns were\nreserved for an identification number, which could be used to automatically\nsort a stack of cards if it were dropped (apparently a perennial hazard).\nAnother column, column seven, could be used to indicate that the statement on\nthis card was a continuation of a statement on a previous card. This meant that\nif you were truly desperate you "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"could"}]},{"type":"text","value":" circumvent the 80-character limit,\nthough whether a two-card statement counts as one long line or just two is\nunclear. FORTRAN cards were similar but had different fields.  Universities\noften watermarked the punch cards handed out by their computing centers, while\nother kinds of designs were introduced for special occasions like the "},{"type":"element","tagName":"a","properties":{"href":"http://www.jkmscott.net/data/Punched%20card%20013.jpg"},"children":[{"type":"text","value":"1976\nbicentennial"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Ultimately the cards had to be read and understood by a computer. IBM sold a\nSystem/360 peripheral called the IBM 2540 which could read up to 1000 cards per\nminute."},{"type":"element","tagName":"sup","properties":{"id":"fnref-2"},"children":[{"type":"element","tagName":"a","properties":{"href":"#fn-2","className":["footnote-ref"]},"children":[{"type":"text","value":"2"}]}]},{"type":"text","value":" The IBM 2540 ran electrical brushes across the surface of each card\nwhich made contact with a plate behind the cards wherever there was a hole.\nOnce read, the System/360 family of computers represented the characters on\neach punch card using an 8-bit encoding called EBCDIC, which stood for Extended\nBinary Coded Decimal Interchange Code. EBCDIC was a proper binary encoding, but\nit still traced its roots back to the punch card via an earlier encoding called\nBCDIC, a 6-bit encoding which used the low four bits to represent a punch\ncard's digit rows and the high two bits to represent the zone rows. Punch card\nprogrammers would typically hand their cards to the actual computer operators,\nwho would feed the cards into the IBM 2540 and then hand the printed results\nback to the programmer. The programmer usually didn't see the computer at all."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"What the programmer did see a lot of was the card punch. The 029 was not a\ncomputer, but that doesn't mean that it wasn't a complicated machine. The best\nway to understand what it was like using the 029 is to watch "},{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=kaQmAybWn-w"},"children":[{"type":"text","value":"this\ninstructional video"}]},{"type":"text","value":" made by the\ncomputing center at the University of Michigan in 1967. I'm going to do my best\nto summarize it here, but if you don't watch the video you will miss out on all\nthe wonderful clacking and whooshing."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The 029 was built around a U-shaped track that the punch cards traveled along.\nOn the right-hand side, at the top of the U, was the card hopper, which you\nwould typically load with a fresh stack of cards before using the machine. The\nIBM 029 worked primarily with 80-column cards, but the card hopper could\naccommodate smaller cards if needed. Your punch cards would start in the card\nhopper, travel along the line of the U, and then end up in the stacker, at the\ntop of the U on the left-hand side. The cards would accumulate there in the\norder that you punched them."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"To turn the machine on, you flipped a switch under the desk at about the height\nof your knees. You then pressed the \"FEED\" key twice to get cards loaded into\nthe machine. The business part of the card track, the bottom of the U, was made\nup of three separate stations: On the right was a kind of waiting area, in the\nmiddle was the punching station, and on the left was the reading station.\nPressing the \"FEED\" key twice loaded one card into the punching station and one\ncard into the waiting area behind it. A column number indicator right above the\npunching station told you which column you were currently punching. With every\nkeystroke, the machine would punch the requisite holes, print the appropriate\ncharacter at the top of the card, and then advance the card through the\npunching station by one column. If you punched all 80 columns, the card would\nautomatically be released to the reading station and a new card would be loaded\ninto the punching station. If you wanted this to happen before you reached the\n80th column, you could press the \"REL\" key (for \"release\")."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The printed characters made it easy to spot a mistake. But fixing a mistake, as\nthe University of Michigan video warns, is not as easy as whiting out the\nprinted character at the top of the card and writing in a new one. The holes\nare all that the computer will read. Nor is it as easy as backspacing one space\nand typing in a new character. The holes have already been punched in the\ncolumn, after all, and cannot be unpunched. Punching more holes will only\nproduce an invalid combination not associated with any character. The IBM 029\ndid have a backspace button that moved the punched card backward one column,\nbut the button was placed on the face of the machine instead of on the\nkeyboard. This was probably done to discourage its use, since backspacing was\nso seldom what the user actually wanted to do."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Instead, the only way to correct a mistake was scrap the incorrect card and\npunch a new one. This is where the reading station came in handy. Say you made\na mistake in the 68th column of a card. To fix your mistake, you could\ncarefully repunch the first 67 columns of a new card and then punch the correct\ncharacter in the 68th column. Alternatively, you could release the incorrect\ncard to the reading station, load a new card into the punching station, and\nhold down the \"DUP\" key (for duplicate) until the column number indicator\nreads 68. You could then correct your mistake by punching the correct\ncharacter. The reading station and the \"DUP\" key together allowed IBM 029\noperators to easily copy the contents of one card to the next. There were all\nsorts of reasons to do this, but correcting mistakes was the most common."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"The \"DUP\" key allowed the 029's operator to invoke the duplicate functionality\nmanually. But the 029 could also duplicate automatically where necessary. This\nwas particularly useful when punched cards were used to record data rather than\nprograms. For example, you might be using each card to record information about\na single undergraduate university student. On each card, you might have a field\nthat contains the name of that student's residence hall. Perhaps you find\nyourself entering data for all the students in one residence hall at one time.\nIn that case, you'd want the 029 to automatically copy over the previous card's\nresidence hall field every time you reached the first column of the field."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Automated behavior like this could be programmed into the 029 by using the\nprogram drum. The drum sat upright in the middle of the U above the punching\nstation. You programmed the 029 by punching holes in a card and wrapping that\ncard around the program drum. The punched card allowed you to specify the\nautomatic behavior you expected from the machine at each column of the card\ncurrently in the punching station. You could specify that a column should\nautomatically be copied from the previous card, which is how an 029 operator\nmight more quickly enter student records. You could also specify, say, that a\nparticular field should contain numeric or alphabetic characters, or that a\ngiven field should be left blank and skipped altogether. The program drum made\nit much easier to punch schematized cards where certain column ranges had\nspecial meanings. There is another "},{"type":"element","tagName":"a","properties":{"href":"https://www.youtube.com/watch?v=SWD1PwNxpoU"},"children":[{"type":"text","value":"\"advanced\" instructional\nvideo"}]},{"type":"text","value":" produced by the University\nof Michigan that covers the program drum that is worth watching, provided, of\ncourse, that you have already mastered the basics."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Watching either of the University of Michigan videos today, what's surprising\nis how easy the card punch is to operate. Correcting mistakes is tedious, but\notherwise the machine seems to be less of an obstacle than I would have\nexpected. Moving from one card to the next is so seamless that I can imagine\nCOBOL or FORTRAN programmers forgetting that they are creating separate cards\nrather than one long continuous text file. On the other hand, it's interesting\nto consider how card punches, even though they were only an input tool,\nprobably limited how early programming languages evolved. Structured\nprogramming would eventually come along and encourage people to think of entire\nblocks of code as one unit, but I can see how punch card programming's emphasis\non each line made structured programming hard to conceive of. It's no wonder\nthat punch card programmers were not the ones that decided to enclose blocks\nwith single curly braces entirely on their own lines. How wasteful that would\nhave seemed!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"So even though nobody programs using punch cards anymore, every programmer\nought to "},{"type":"element","tagName":"a","properties":{"href":"http://www.masswerk.at/keypunch/"},"children":[{"type":"text","value":"try it"}]},{"type":"text","value":" at least once—if only to\nunderstand why COBOL and FORTRAN look the way they do, or how 80 characters\nsomehow became everybody's favorite character limit."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{"style":"color:#5f5f5f;font-size:16px;font-style: italic;padding-top:2em;text-align:center"},"children":[{"type":"text","value":"\noriginally posted at "},{"type":"element","tagName":"a","properties":{"href":"https://twobithistory.org"},"children":[{"type":"text","value":"two bit history"}]},{"type":"text","value":" under \n"},{"type":"element","tagName":"a","properties":{"href":"https://creativecommons.org/licenses/by-sa/4.0/"},"children":[{"type":"text","value":"CC BY-SA 4.0"}]},{"type":"text","value":" by "},{"type":"element","tagName":"a","properties":{"href":"http://sinclairtarget.com"},"children":[{"type":"text","value":"Sinclair Target"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"div","properties":{"className":["footnotes"]},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-1"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"\"IBM 29 Card Punch,\" IBM Archives, accessed June 23, 2018, "},{"type":"element","tagName":"a","properties":{"href":"https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html"},"children":[{"type":"text","value":"https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-1","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{"id":"fn-2"},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"IBM, IBM 2540 Component Description and Operation Procedures (Rochester, MN: IBM Product Publications, 1965), September 06, 2009, accessed June 23, 2018, "},{"type":"element","tagName":"a","properties":{"href":"http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf"},"children":[{"type":"text","value":"http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf"}]},{"type":"text","value":"."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"a","properties":{"href":"#fnref-2","className":["footnote-backref"]},"children":[{"type":"text","value":"↩"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"frontmatter":{"title":"The IBM 029 Card Punch","author":{"name":"Sinclair Target"},"date":"23 June 2018"}}},"pageContext":{"slug":"/blog/series/2bithistory/ibm-029-card-punch/"}}